---
sidebar_position: 1
title: "Linters"
---

# Adding a new linter

ELP provides a flexible framework for adding custom linters (diagnostics) to
detect issues in Erlang code. This guide walks you through the process of
creating a new linter.

## Overview

Linters in ELP are implemented as diagnostics that analyze Erlang code and
report issues.
Today ELP counts over [50 linters](https://github.com/WhatsApp/erlang-language-platform/tree/main/crates/ide/src/diagnostics),
and the number is growing. It is usually a good idea to look at existing linters to ensure a similar functionality is not already provided and to get inspiration for a new linter.

At high level, each linter consists of:

1. A **DiagnosticCode** - A unique identifier for the diagnostic
2. A **DiagnosticDescriptor** - Configuration for when and how the diagnostic runs
3. **Tests** - A number of test cases for the diagnostic
4. **Documentation** - A user-facing explanation of the diagnostic

## Example: Detecting unsafe function calls

Let's create a linter that warns about calls to a hypothetical
`unsafe:operation/1` API that should be avoided in production code.

### Step 1: Add the Diagnostic Code

First, add a new variant to the `DiagnosticCode` enum in
[`crates/ide_db/src/diagnostic_code.rs`](https://github.com/WhatsApp/erlang-language-platform/blob/main/crates/ide_db/src/diagnostic_code.rs):

```rust
pub enum DiagnosticCode {
    // ... existing codes ...
    UnsafeFunctionCall, // This is the new code

    // Wrapper for erlang service diagnostic codes
    ErlangService(String),
    // Wrapper for EqWAlizer diagnostic codes
    Eqwalizer(String),
    // Used for ad-hoc diagnostics via lints/codemods
    AdHoc(String),
}
```

Ensure the code name is unique and descriptive.
Then add a clause for each of the required methods:

```rust
impl DiagnosticCode {
    // The `as_code` method returns a string representation of the code.
    // This is used to identify the diagnostic in the UI and in the CLI.
    // Each code emitted by ELP starts with a `W` prefix, followed by a 4-digit number.
    // The number is assigned by the linter author and should be unique within the linter.
    // Use the next available number in the sequence for your new linter.
    pub fn as_code(&self) -> &'static str {
        match self {
            // ... existing cases ...
            DiagnosticCode::UnsafeFunctionCall => "W0055", // Use next available number here

            DiagnosticCode::ErlangService(c) => c.to_string(),
            DiagnosticCode::Eqwalizer(c) => format!("eqwalizer: {c}"),
            DiagnosticCode::AdHoc(c) => format!("ad-hoc: {c}"),
        }
    }

    // The `as_label` method returns a human-readable label for the diagnostic.
    // This is used to identify the diagnostic in the UI and in the CLI.
    // The label should be unique and descriptive.
    pub fn as_label(&self) -> &'static str {
        match self {
            // ... existing cases ...
            DiagnosticCode::UnsafeFunctionCall => "unsafe_function_call", // Use snake_case here

            DiagnosticCode::ErlangService(c) => c.to_string(),
            DiagnosticCode::Eqwalizer(c) => c.to_string(),
            DiagnosticCode::AdHoc(c) => format!("ad-hoc: {c}"),
        }
    }

    // The `allows_fixme_comment` method determines if it should be possible to temporarily
    // suppress the diagnostic by a `% elp:fixme` annotation.
    pub fn allows_fixme_comment(&self) -> bool {
        match self {
            // ... existing cases ...
            DiagnosticCode::UnsafeFunctionCall => false,

            DiagnosticCode::ErlangService(_) => false,
            DiagnosticCode::Eqwalizer(_) => false,
            DiagnosticCode::AdHoc(_) => false,
        }
    }

}
```

### Step 2: Create the diagnostic module

Create a new file `elp/crates/ide/src/diagnostics/unsafe_function_call.rs`, with the following content.
The code has comments to explain each part.

```rust
/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is dual-licensed under either the MIT license found in the
 * LICENSE-MIT file in the root directory of this source tree or the Apache
 * License, Version 2.0 found in the LICENSE-APACHE file in the root directory
 * of this source tree. You may select, at your option, one of the
 * above-listed licenses.
 */

use elp_ide_db::DiagnosticCode;
use elp_ide_ssr::match_pattern_in_file_functions;
use hir::Strategy;
use hir::fold::MacroStrategy;
use hir::fold::ParenStrategy;

use crate::diagnostics::Diagnostic;
use crate::diagnostics::DiagnosticConditions;
use crate::diagnostics::DiagnosticDescriptor;
use crate::diagnostics::Severity;

// This is the enum entry which will be used to identify the diagnostic
const DIAGNOSTIC_CODE: DiagnosticCode = DiagnosticCode::UnsafeFunctionCall;
// This is a human-readable message that will be displayed in the IDE
const DIAGNOSTIC_MESSAGE: &str = "Do not use unsafe:operation/1 in production code.";
// This is the severity of the diagnostic (Warning, Error, etc.)
const DIAGNOSTIC_SEVERITY: Severity = Severity::Warning;
// This is the strategy used to match the pattern in the code.
const STRATEGY: Strategy = Strategy {
    // In our case we want to expand macros before matching the pattern
    macros: MacroStrategy::Expand,
    // We don't care about parentheses in our case, so we ignore them
    parens: ParenStrategy::InvisibleParens,
};

// This is the core of our linter.
pub(crate) static DESCRIPTOR: DiagnosticDescriptor = DiagnosticDescriptor {
    // These are the conditions under which the diagnostic should run.
    conditions: DiagnosticConditions {
        experimental: false, // Experimental diagnostics are only enabled in `--experimental` mode
        include_generated: false, // Do not run the linters against generated files
        include_tests: false, // Do not run the linters against test files
        default_disabled: false, // The diagnostic is enabled by default
    },
    // This is the function that will be called to run the diagnostic.
    // `acc` is a vector of diagnostics which will be adding to.
    checker: &|acc, sema, file_id, _ext| {
        // We use the SSR mechanism to match calls to `unsafe:operation/1`.
        let pattern = "ssr: unsafe:operation(_@).";
        // We use the `match_pattern_in_file_functions` function to match the pattern in the code.
        let matches = match_pattern_in_file_functions(sema, STRATEGY, file_id, pattern);
        // We iterate over the matches and add a diagnostic for each one
        matches.matches.iter().for_each(|m| {
            // We create a new diagnostic with the code, message, and range of the match
            let diagnostic = Diagnostic::new(DIAGNOSTIC_CODE, DIAGNOSTIC_MESSAGE, m.range.range)
                .with_severity(DIAGNOSTIC_SEVERITY);
            // We add the diagnostic to the accumulator
            acc.push(diagnostic);
        });
    },
};
```

### Step 3: Register the diagnostic

Add your diagnostic module to [`elp/crates/ide/src/diagnostics.rs`](https://github.com/WhatsApp/erlang-language-platform/blob/main/crates/ide/src/diagnostics.rs):

```rust
// Add the module declaration
mod unsafe_function_call;

// Register the descriptor in the diagnostics_descriptors function
pub fn diagnostics_descriptors() -> Vec<&'static DiagnosticDescriptor> {
    vec![
        // ... existing descriptors ...
        &unsafe_function_call::DESCRIPTOR, // We add the descriptor here
    ]
}
```

### Step 4: Add tests

At the bottom of the `unsafe_function_call.rs` file, add the following:

```rust
#[cfg(test)]
mod tests {
    use crate::tests::check_diagnostics;

    #[test]
    fn test_unsafe_function_call() {
        check_diagnostics(
            r#"
            //- /src/main.erl
            -module(main).
            -export([warn/0]).
            warn() ->
                unsafe:operation(data),
            %%  ^^^^^^^^^^^^^^^^^^^^^^ warning: Do not use unsafe:operation/1 in production code.
                safe:operation(data).
            //- /src/unsafe.erl
            -module(unsafe).
            -export([operation/1]).
            operation(_) -> ok.
            //- /src/safe.erl
            -module(safe).
            -export([operation/1]).
            operation(_) -> ok.
            "#,
        );
    }
}
```

ELP uses convenient snapshot tests for checking diagnostics. The test above
checks that the diagnostic is correctly reported when calling `unsafe:operation/1`.
It also checks that the diagnostic is not reported when calling `safe:operation/1`.

Always include comprehensive tests in your diagnostic module:

1. **Positive cases** - Code that should trigger the diagnostic
2. **Negative cases** - Similar code that should NOT trigger the diagnostic
3. **Edge cases** - Boundary conditions and unusual syntax

You can run the tests with the following command:

```
cargo test --package elp_ide --lib -- diagnostics::unsafe_function_call::tests::test_unsafe_function_call --exact --show-output
```

### Step 5: Create documentation

Each new linter must be accompanied by a documentation file in Markdown format.
Create the documentation file corresponding to your linter in:
`elp/website/docs/erlang-error-index/w/W0055.md` (where `W0055` is the code we introduced):

````markdown
---
sidebar_position: 55
---

# W0055 - Unsage Function Call

This diagnostic warns about calls to `unsafe:operation/1`, which should be
avoided in production code due to potential security or stability risks.
`safe:operation/1` is a safer alternative that should be used instead.

## Example

```erlang
-module(example).
-export([do/1]).

do(Data) ->
    unsafe:operation(Data).
%%  ^^^^^^^^^^^^^^^^^^^^^^ warning: Do not use unsafe:operation/1 in production code.
```

## Recommended fix

Replace calls to `unsafe:operation/1` with a safer alternative, such as `safe:operation/1`.

```erlang
-module(example).
-export([do/1]).

do(Data) ->
    safe:operation(Data).
```
````

### Step 6: Try the new linter from the CLI

After building ELP, you can try the new linter against a hypothetical `my_module` Erlang module:

```
cargo run --bin elp -- lint --project /path/to/your/project --module my_module --diagnostic-filter unsafe_function_call
```

```
Diagnostics reported in 1 modules:
  my_module: 1
      29:4-29:25::[Warning] [W0055] Do not use unsafe:operation/1 in production code.
```
