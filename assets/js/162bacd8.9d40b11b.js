"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[8214],{72119:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"contributing/linters/linters-step-2-module","title":"Create the linter module","description":"Create a new file elp/crates/ide/src/diagnostics/nounsafeoperation.rs, with","source":"@site/docs/contributing/linters/linters-step-2-module.md","sourceDirName":"contributing/linters","slug":"/contributing/linters/linters-step-2-module","permalink":"/erlang-language-platform/docs/contributing/linters/linters-step-2-module","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Create the linter module"},"sidebar":"tutorialSidebar","previous":{"title":"Add a Diagnostic Code","permalink":"/erlang-language-platform/docs/contributing/linters/linters-step-1-diagnostic-code"},"next":{"title":"Test your linter","permalink":"/erlang-language-platform/docs/contributing/linters/linters-step-3-tests"}}');var r=t(74848),s=t(28453);const o={sidebar_position:2,title:"Create the linter module"},a=void 0,c={},l=[];function d(e){const n={a:"a",code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Create a new file ",(0,r.jsx)(n.code,{children:"elp/crates/ide/src/diagnostics/no_unsafe_operation.rs"}),", with\nthe following content. The code has comments to explain each part."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:"showLineNumbers",children:'/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is dual-licensed under either the MIT license found in the\n * LICENSE-MIT file in the root directory of this source tree or the Apache\n * License, Version 2.0 found in the LICENSE-APACHE file in the root directory\n * of this source tree. You may select, at your option, one of the\n * above-listed licenses.\n */\n\nuse elp_ide_db::DiagnosticCode;\n\nuse crate::diagnostics::Linter;\nuse crate::diagnostics::SsrPatternsLinter;\n\n// We define a new linter, named `NoUnsafeOperationLinter`\npub(crate) struct NoUnsafeOperationLinter;\n\n// We implement the `Linter` trait. This is common to all kinds of ELP linters.\nimpl Linter for NoUnsafeOperationLinter {\n    // A unique identifier for the linter. This is the `DiagnosticCode` we just added.\n    fn id(&self) -> DiagnosticCode {\n        DiagnosticCode::NoUnsafeOperationLinter\n    }\n    // A human-readable description for the linter, which will be displayed in the IDE\n    fn description(&self) -> String {\n        "Do not use unsafe:operation/1 in production code.".to_string()\n    }\n    // By default test files (i.e. test suites and helpers) are processed by linters.\n    // Since we only care about "unsafe calls" from production code,\n    // here we override the default behaviour by skipping test files.\n    fn should_process_test_files(&self) -> bool {\n        false\n    }\n}\n\n// We will write our linter using the so-called "SSR" syntax.\n// SSR is a convenient way to match on parts of the Erlang AST.\n// Because of this, we decide to implement the additional `SsrPatternsLinter` trait.\nimpl SsrPatternsLinter for NoUnsafeOperationLinter {\n    // Linters can specify a custom context type. For now, we ignore it.\n    type Context = ();\n\n    // Here we specify which patterns we want to match.\n    // The function returns a vector of tuples, each one containing\n    // a SSR pattern and a context.\n    // For the time being, let\'s ignore the context.\n    // For SSR syntax, please refer to the `ide_ssr` crate.\n    // Here, we are matching on calls to the fully-qualified `unsafe:operation/1`\n    // function, ignoring its only argument.\n    fn patterns(&self) -> Vec<(String, Self::Context)> {\n        // We use the SSR mechanism to match calls to `unsafe:operation/1`.\n        vec![("ssr: unsafe:operation(_@).".to_string(), ())]\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The only thing left to do is to register the linter in the\n",(0,r.jsx)(n.a,{href:"https://github.com/WhatsApp/erlang-language-platform/blob/main/crates/ide/src/diagnostics.rs",children:(0,r.jsx)(n.code,{children:"elp/crates/ide/src/diagnostics.rs"})}),"\nfile:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",metastring:"{8} showLineNumbers",children:"// Add the module declaration\nmod no_unsafe_operation;\n\n// Register the linter in the `ssr_linters` function\npub(crate) fn ssr_linters() -> Vec<&'static dyn FunctionCallLinter> {\n    vec![\n        // ... existing linters ...\n        &no_unsafe_operation::LINTER, // We add the linter here\n    ]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this case we have been using the ",(0,r.jsx)(n.code,{children:"SsrPatternsLinter"})," trait, which is a\nconvenient way to match on parts of the Erlang AST. You can learn more about the\n",(0,r.jsx)(n.code,{children:"SsrPatternsLinter"})," and other available linter traits in the\n",(0,r.jsx)(n.a,{href:"/docs/contributing/linters/linter-traits",children:"linter traits"})," section."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);