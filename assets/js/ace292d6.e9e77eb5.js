"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[6285],{95507:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"contributing/linters/linter-traits","title":"Linter Traits","description":"Linters are implemented using Rust","source":"@site/docs/contributing/linters/linter-traits.md","sourceDirName":"contributing/linters","slug":"/contributing/linters/linter-traits","permalink":"/erlang-language-platform/docs/contributing/linters/linter-traits","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Linter Traits"},"sidebar":"tutorialSidebar","previous":{"title":"Document your linter","permalink":"/erlang-language-platform/docs/contributing/linters/linters-step-4-documentation"},"next":{"title":"Code Actions (a.k.a. Assists)","permalink":"/erlang-language-platform/docs/contributing/code-actions"}}');var s=t(74848),r=t(28453);const a={sidebar_position:6,title:"Linter Traits"},o=void 0,l={},c=[{value:"The <code>Linter</code> trait",id:"the-linter-trait",level:2},{value:"Additional linter traits",id:"additional-linter-traits",level:2},{value:"FunctionCallLinter",id:"functioncalllinter",level:3},{value:"Trait Methods",id:"trait-methods",level:4},{value:"Example Usage",id:"example-usage",level:4},{value:"SsrPatternsLinter",id:"ssrpatternslinter",level:3},{value:"Trait Methods",id:"trait-methods-1",level:4},{value:"SSR Pattern Syntax",id:"ssr-pattern-syntax",level:4},{value:"Example Usage",id:"example-usage-1",level:4},{value:"GenericLinter",id:"genericlinter",level:3},{value:"Trait Methods",id:"trait-methods-2",level:4},{value:"GenericLinterMatchContext",id:"genericlintermatchcontext",level:4},{value:"Example Usage",id:"example-usage-2",level:4},{value:"Choosing the Right Trait",id:"choosing-the-right-trait",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Linters are implemented using Rust\n",(0,s.jsx)(n.a,{href:"https://doc.rust-lang.org/book/ch10-02-traits.html",children:"traits"})," (think interfaces,\nor Erlang behaviours). This allows linter authors to minimize the amount of\nboilerplate code they need to write, and makes it easier to write and maintain\nlinters."]}),"\n",(0,s.jsxs)(n.h2,{id:"the-linter-trait",children:["The ",(0,s.jsx)(n.code,{children:"Linter"})," trait"]}),"\n",(0,s.jsxs)(n.p,{children:["Each linter must implement the ",(0,s.jsx)(n.code,{children:"Linter"})," trait, which has the following mandatory\nmethods:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// A unique identifier for the linter.\nfn id(&self) -> DiagnosticCode;\n\n// A plain-text description for the linter. Displayed to the end user.\nfn description(&self) -> &'static str;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Linter"})," trait also has a few optional methods that can be used to customize\nthe linter's behavior, if needed:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"\n// The severity for the lint issue. It defaults to `Warning`.\nfn severity(&self) -> Severity {\n    Severity::Warning\n}\n\n// For CLI, when using the --use-cli-severity flag. It defaults to `severity()`\nfn cli_severity(&self) -> Severity {\n    self.severity()\n}\n\n// Specify if the linter issues can be suppressed via a `% elp:ignore` comment.\nfn can_be_suppressed(&self) -> bool {\n    true\n}\n\n// Specify if the linter should only run when the `--experimental` flag is specified.\nfn is_experimental(&self) -> bool {\n    false\n}\n\n// Specify if the linter is enabled by default.\nfn is_enabled(&self) -> bool {\n    true\n}\n\n// Specify if the linter should process generated files.\nfn should_process_generated_files(&self) -> bool {\n    false\n}\n\n// Specify if the linter should process generated test files (including test helpers)\nfn should_process_test_files(&self) -> bool {\n    true\n}\n\n// Specify if the linter should process the given file id.\nfn should_process_file_id(&self, _sema: &Semantic, _file_id: FileId) -> bool {\n    true\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"additional-linter-traits",children:"Additional linter traits"}),"\n",(0,s.jsxs)(n.p,{children:["In addition to the ",(0,s.jsx)(n.code,{children:"Linter"})," trait, ELP provides a few additional traits, each\nsuitable for a specific type of linter. These traits are:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"FunctionCallLinter"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"SsrPatternsLinter"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"GenericLinter"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let's look at each of these traits in more detail."}),"\n",(0,s.jsx)(n.h3,{id:"functioncalllinter",children:"FunctionCallLinter"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"FunctionCallLinter"})," trait provides an efficient way to match against\nfunction calls by name, module, and arity. This is the most common type of\nlinter in ELP."]}),"\n",(0,s.jsx)(n.h4,{id:"trait-methods",children:"Trait Methods"}),"\n",(0,s.jsx)(n.p,{children:"The trait provides the following methods:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"showLineNumbers",children:"/// Associated type - each linter defines its own context for passing data between callbacks\ntype Context: Clone + fmt::Debug + PartialEq + Default;\n\n/// Specify which functions to match against\nfn matches_functions(&self) -> Vec<FunctionMatch>;\n\n/// Specify functions to exclude from matching (optional)\nfn excludes_functions(&self) -> Vec<FunctionMatch>;\n\n/// Custom validation logic for each matched call (optional)\nfn check_match(&self, _check_call_context: &CheckCallCtx<'_, ()>) -> Option<Self::Context>;\n\n/// Provide quick-fixes for matched calls (optional)\nfn fixes(&self, _match_context: &MatchCtx<Self::Context>, _sema: &Semantic, _file_id: FileId) -> Option<Vec<Assist>>;\n\n/// Customize the diagnostic message per match (optional)\nfn match_description(&self, _context: &Self::Context) -> Cow<'_, str>;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"example-usage",children:"Example Usage"}),"\n",(0,s.jsxs)(n.p,{children:["Here's how you might implement a linter that flags calls to\n",(0,s.jsx)(n.code,{children:"erlang:garbage_collect/0"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"showLineNumbers",children:'use crate::lazy_function_matches;\n\npub(crate) struct NoGarbageCollectLinter;\n\nimpl Linter for NoGarbageCollectLinter {\n    fn id(&self) -> DiagnosticCode {\n        DiagnosticCode::NoGarbageCollect\n    }\n\n    fn description(&self) -> &\'static str {\n        "Avoid forcing garbage collection."\n    }\n}\n\nimpl FunctionCallLinter for NoGarbageCollectLinter {\n    type Context = ();\n\n    fn matches_functions(&self) -> Vec<FunctionMatch> {\n        lazy_function_matches![\n            FunctionMatch::mfa("erlang", "garbage_collect", 0),\n        ]\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ssrpatternslinter",children:"SsrPatternsLinter"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SsrPatternsLinter"})," trait uses Structural Search and Replace (SSR) patterns\nto match complex code structures, that go beyond simple function calls. SSR\nprovides a powerful way to express patterns in Erlang syntax, but it can be\nslower than other approaches."]}),"\n",(0,s.jsxs)(n.p,{children:["Ssr patterns can also be used to match function calls, but they require a\npattern for each function arity. So, if you need to match on multiple function\narities, you should consider the ",(0,s.jsx)(n.code,{children:"FunctionCallLinter"})," trait instead."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SsrPatternsLinter"})," trait is ideal for:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Complex pattern matching beyond simple function calls"}),"\n",(0,s.jsx)(n.li,{children:"Matching code structures like specific usage patterns"}),"\n",(0,s.jsx)(n.li,{children:"Finding and replacing complex expressions"}),"\n",(0,s.jsx)(n.li,{children:"Matching code patterns with placeholders and variables"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"trait-methods-1",children:"Trait Methods"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"showLineNumbers",children:"/// Associated type for the pattern context - each linter defines its own\ntype Context: Clone + fmt::Debug + PartialEq;\n\n/// Specify the SSR patterns to match. Each pattern is paired with a context\n/// for distinguishing between different patterns.\nfn patterns(&self) -> Vec<(String, Self::Context)>;\n\n/// Customize the diagnostic message for each pattern (optional)\nfn pattern_description(&self, _context: &Self::Context) -> &'static str;\n\n/// Validate that a match is legitimate (optional)\nfn is_match_valid(&self, _context: &Self::Context, _matched: &Match, _sema: &Semantic, _file_id: FileId) -> Option<bool>;\n\n/// Provide quick-fixes for matched patterns (optional)\nfn fixes(&self, _context: &Self::Context, _matched: &Match, _sema: &Semantic, _file_id: FileId) -> Option<Vec<Assist>>;\n\n/// Specify additional diagnostic categories (optional)\nfn add_categories(&self, _context: &Self::Context) -> Vec<Category>;\n\n/// Configure how macros and parentheses are handled (optional)\nfn strategy(&self) -> Strategy;\n\n/// Define the search scope - entire file or functions only (optional)\nfn scope(&self, file_id: FileId) -> SsrSearchScope;\n\n/// Customize the diagnostic range (optional)\nfn range(&self, _sema: &Semantic, _matched: &Match) -> Option<TextRange>;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"ssr-pattern-syntax",children:"SSR Pattern Syntax"}),"\n",(0,s.jsx)(n.p,{children:"SSR patterns use a special syntax where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"$var"})," represents a placeholder that matches any expression"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"_@"})," represents a wildcard that matches anything"]}),"\n",(0,s.jsx)(n.li,{children:"You can use regular Erlang syntax for the rest of the pattern"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-usage-1",children:"Example Usage"}),"\n",(0,s.jsx)(n.p,{children:"Here's how you might implement a linter that detects inefficient map-to-list\nconversions in comprehensions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"showLineNumbers",children:'#[derive(Debug, Clone, PartialEq)]\nenum MapToListPattern {\n    MapToList,\n}\n\npub(crate) struct UnnecessaryMapToListLinter;\n\nimpl Linter for UnnecessaryMapToListLinter {\n    fn id(&self) -> DiagnosticCode {\n        DiagnosticCode::UnnecessaryMapToListInComprehension\n    }\n\n    fn description(&self) -> &\'static str {\n        "Avoid maps:to_list/1 in list comprehensions"\n    }\n}\n\nimpl SsrPatternsLinter for UnnecessaryMapToListLinter {\n    type Context = MapToListPattern;\n\n    fn patterns(&self) -> Vec<(String, Self::Context)> {\n        vec![\n            (\n                "ssr: [V || {_@, V} <- maps:to_list($M)]".to_string(),\n                MapToListPattern::MapToList,\n            ),\n        ]\n    }\n\n    fn pattern_description(&self, _context: &Self::Context) -> &\'static str {\n        "Use maps:values/1 instead of list comprehension with maps:to_list/1"\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"genericlinter",children:"GenericLinter"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"GenericLinter"})," trait provides the most flexibility, allowing you to\nimplement completely custom matching logic. You should use this trait only when\nthe other two options don't fit your use case."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"GenericLinter"})," trait is ideal for:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Custom traversal and analysis of the AST"}),"\n",(0,s.jsx)(n.li,{children:"Complex cross-function or cross-module analysis"}),"\n",(0,s.jsx)(n.li,{children:"Linters that need fine-grained control over the matching process"}),"\n",(0,s.jsx)(n.li,{children:"Situations where neither function call matching nor SSR patterns are\nsufficient"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"trait-methods-2",children:"Trait Methods"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"showLineNumbers",children:"/// Associated type for passing context between the matching and diagnostic phases\ntype Context: Clone + fmt::Debug + PartialEq + Default;\n\n/// Return a list of matches found in the file\n/// This is where you implement your custom matching logic\nfn matches(&self, _sema: &Semantic, _file_id: FileId) -> Option<Vec<GenericLinterMatchContext<Self::Context>>>;\n\n/// Customize the diagnostic message for each match (optional)\nfn match_description(&self, _context: &Self::Context) -> Cow<'_, str>;\n\n/// Add diagnostic tags like Unused or Deprecated (optional)\nfn tag(&self, _context: &Self::Context) -> Option<DiagnosticTag>;\n\n/// Provide quick-fixes for each match (optional)\nfn fixes(&self, _context: &Self::Context, _sema: &Semantic, _file_id: FileId) -> Option<Vec<Assist>>;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"genericlintermatchcontext",children:"GenericLinterMatchContext"}),"\n",(0,s.jsxs)(n.p,{children:["When returning matches from the ",(0,s.jsx)(n.code,{children:"matches()"})," method, you need to wrap your\ncontext in a ",(0,s.jsx)(n.code,{children:"GenericLinterMatchContext"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"showLineNumbers",children:"GenericLinterMatchContext {\n    range: TextRange,    // The text range where the diagnostic should appear\n    context: Context,    // Your custom context data\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"example-usage-2",children:"Example Usage"}),"\n",(0,s.jsx)(n.p,{children:"Here's how you might implement a linter that detects unused macros:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"showLineNumbers",children:"#[derive(Debug, Clone, PartialEq, Default)]\nstruct UnusedMacroContext {\n    macro_name: String,\n}\n\npub(crate) struct UnusedMacroLinter;\n\nimpl Linter for UnusedMacroLinter {\n    fn id(&self) -> DiagnosticCode {\n        DiagnosticCode::UnusedMacro\n    }\n\n    fn description(&self) -> &'static str {\n        \"This macro is never used\"\n    }\n}\n\nimpl GenericLinter for UnusedMacroLinter {\n    type Context = UnusedMacroContext;\n\n    fn matches(&self, sema: &Semantic, file_id: FileId) -> Option<Vec<GenericLinterMatchContext<Self::Context>>> {\n        let mut matches = Vec::new();\n\n        // Custom logic to find unused macros\n        let source_file = sema.parse(file_id);\n        let form_list = sema.form_list(file_id);\n\n        // Collect all macro definitions\n        let defined_macros = collect_defined_macros(&form_list, &source_file.value);\n\n        // Collect all macro usages\n        let used_macros = collect_used_macros(&source_file.value);\n\n        // Find unused macros\n        for (name, range) in defined_macros {\n            if !used_macros.contains(&name) {\n                matches.push(GenericLinterMatchContext {\n                    range,\n                    context: UnusedMacroContext { macro_name: name },\n                });\n            }\n        }\n\n        if matches.is_empty() {\n            None\n        } else {\n            Some(matches)\n        }\n    }\n\n    fn match_description(&self, context: &Self::Context) -> Cow<'_, str> {\n        Cow::Owned(format!(\"Macro '{}' is never used\", context.macro_name))\n    }\n\n    fn tag(&self, _context: &Self::Context) -> Option<DiagnosticTag> {\n        Some(DiagnosticTag::Unused)\n    }\n}\n\n// Helper functions would be implemented here\nfn collect_defined_macros(form_list: &FormList, source_file: &SourceFile) -> Vec<(String, TextRange)> {\n    // Implementation details...\n    vec![]\n}\n\nfn collect_used_macros(source_file: &SourceFile) -> HashSet<String> {\n    // Implementation details...\n    HashSet::new()\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"choosing-the-right-trait",children:"Choosing the Right Trait"}),"\n",(0,s.jsx)(n.p,{children:"When deciding which trait to use for your linter:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Use ",(0,s.jsx)(n.code,{children:"FunctionCallLinter"})]})," if you need to match specific function calls by\nmodule, name, and arity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Use ",(0,s.jsx)(n.code,{children:"SsrPatternsLinter"})]})," if you need to match complex code patterns that\ngo beyond simple function calls"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:["Use ",(0,s.jsx)(n.code,{children:"GenericLinter"})]})," if you need complete control over the matching logic\nor need to perform complex analysis"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Most linters in ELP use the ",(0,s.jsx)(n.code,{children:"FunctionCallLinter"})," trait since it covers the\ncommon case efficiently."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);