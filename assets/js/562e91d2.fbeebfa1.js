"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[2797],{48227:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"contributing/linters","title":"Linters","description":"ELP provides a flexible framework for adding custom linters (diagnostics) to","source":"@site/docs/contributing/linters.mdx","sourceDirName":"contributing","slug":"/contributing/linters","permalink":"/erlang-language-platform/docs/contributing/linters","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Linters"},"sidebar":"tutorialSidebar","previous":{"title":"Contributing","permalink":"/erlang-language-platform/docs/contributing/"},"next":{"title":"Code Actions (a.k.a. Assists)","permalink":"/erlang-language-platform/docs/contributing/code-actions"}}');var s=t(74848),a=t(28453);const o={sidebar_position:1,title:"Linters"},r="Adding a new linter",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Example: Detecting unsafe function calls",id:"example-detecting-unsafe-function-calls",level:2},{value:"Step 1: Add the Diagnostic Code",id:"step-1-add-the-diagnostic-code",level:3},{value:"Step 2: Create the diagnostic module",id:"step-2-create-the-diagnostic-module",level:3},{value:"Step 3: Register the diagnostic",id:"step-3-register-the-diagnostic",level:3},{value:"Step 4: Add tests",id:"step-4-add-tests",level:3},{value:"Step 5: Create documentation",id:"step-5-create-documentation",level:3},{value:"Step 6: Try the new linter from the CLI",id:"step-6-try-the-new-linter-from-the-cli",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"adding-a-new-linter",children:"Adding a new linter"})}),"\n",(0,s.jsx)(n.p,{children:"ELP provides a flexible framework for adding custom linters (diagnostics) to\ndetect issues in Erlang code. This guide walks you through the process of\ncreating a new linter."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["Linters in ELP are implemented as diagnostics that analyze Erlang code and\nreport issues.\nToday ELP counts over ",(0,s.jsx)(n.a,{href:"https://github.com/WhatsApp/erlang-language-platform/tree/main/crates/ide/src/diagnostics",children:"50 linters"}),",\nand the number is growing. It is usually a good idea to look at existing linters to ensure a similar functionality is not already provided and to get inspiration for a new linter."]}),"\n",(0,s.jsx)(n.p,{children:"At high level, each linter consists of:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.strong,{children:"DiagnosticCode"})," - A unique identifier for the diagnostic"]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.strong,{children:"DiagnosticDescriptor"})," - Configuration for when and how the diagnostic runs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tests"})," - A number of test cases for the diagnostic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Documentation"})," - A user-facing explanation of the diagnostic"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-detecting-unsafe-function-calls",children:"Example: Detecting unsafe function calls"}),"\n",(0,s.jsxs)(n.p,{children:["Let's create a linter that warns about calls to a hypothetical\n",(0,s.jsx)(n.code,{children:"unsafe:operation/1"})," API that should be avoided in production code."]}),"\n",(0,s.jsx)(n.h3,{id:"step-1-add-the-diagnostic-code",children:"Step 1: Add the Diagnostic Code"}),"\n",(0,s.jsxs)(n.p,{children:["First, add a new variant to the ",(0,s.jsx)(n.code,{children:"DiagnosticCode"})," enum in\n",(0,s.jsx)(n.a,{href:"https://github.com/WhatsApp/erlang-language-platform/blob/main/crates/ide_db/src/diagnostic_code.rs",children:(0,s.jsx)(n.code,{children:"crates/ide_db/src/diagnostic_code.rs"})}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"pub enum DiagnosticCode {\n    // ... existing codes ...\n    UnsafeFunctionCall, // This is the new code\n\n    // Wrapper for erlang service diagnostic codes\n    ErlangService(String),\n    // Wrapper for EqWAlizer diagnostic codes\n    Eqwalizer(String),\n    // Used for ad-hoc diagnostics via lints/codemods\n    AdHoc(String),\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Ensure the code name is unique and descriptive.\nThen add a clause for each of the required methods:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'impl DiagnosticCode {\n    // The `as_code` method returns a string representation of the code.\n    // This is used to identify the diagnostic in the UI and in the CLI.\n    // Each code emitted by ELP starts with a `W` prefix, followed by a 4-digit number.\n    // The number is assigned by the linter author and should be unique within the linter.\n    // Use the next available number in the sequence for your new linter.\n    pub fn as_code(&self) -> &\'static str {\n        match self {\n            // ... existing cases ...\n            DiagnosticCode::UnsafeFunctionCall => "W0055", // Use next available number here\n\n            DiagnosticCode::ErlangService(c) => c.to_string(),\n            DiagnosticCode::Eqwalizer(c) => format!("eqwalizer: {c}"),\n            DiagnosticCode::AdHoc(c) => format!("ad-hoc: {c}"),\n        }\n    }\n\n    // The `as_label` method returns a human-readable label for the diagnostic.\n    // This is used to identify the diagnostic in the UI and in the CLI.\n    // The label should be unique and descriptive.\n    pub fn as_label(&self) -> &\'static str {\n        match self {\n            // ... existing cases ...\n            DiagnosticCode::UnsafeFunctionCall => "unsafe_function_call", // Use snake_case here\n\n            DiagnosticCode::ErlangService(c) => c.to_string(),\n            DiagnosticCode::Eqwalizer(c) => c.to_string(),\n            DiagnosticCode::AdHoc(c) => format!("ad-hoc: {c}"),\n        }\n    }\n\n    // The `allows_fixme_comment` method determines if it should be possible to temporarily\n    // suppress the diagnostic by a `% elp:fixme` annotation.\n    pub fn allows_fixme_comment(&self) -> bool {\n        match self {\n            // ... existing cases ...\n            DiagnosticCode::UnsafeFunctionCall => false,\n\n            DiagnosticCode::ErlangService(_) => false,\n            DiagnosticCode::Eqwalizer(_) => false,\n            DiagnosticCode::AdHoc(_) => false,\n        }\n    }\n\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-create-the-diagnostic-module",children:"Step 2: Create the diagnostic module"}),"\n",(0,s.jsxs)(n.p,{children:["Create a new file ",(0,s.jsx)(n.code,{children:"elp/crates/ide/src/diagnostics/unsafe_function_call.rs"}),", with the following content.\nThe code has comments to explain each part."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is dual-licensed under either the MIT license found in the\n * LICENSE-MIT file in the root directory of this source tree or the Apache\n * License, Version 2.0 found in the LICENSE-APACHE file in the root directory\n * of this source tree. You may select, at your option, one of the\n * above-listed licenses.\n */\n\nuse elp_ide_db::DiagnosticCode;\nuse elp_ide_ssr::match_pattern_in_file_functions;\nuse hir::Strategy;\nuse hir::fold::MacroStrategy;\nuse hir::fold::ParenStrategy;\n\nuse crate::diagnostics::Diagnostic;\nuse crate::diagnostics::DiagnosticConditions;\nuse crate::diagnostics::DiagnosticDescriptor;\nuse crate::diagnostics::Severity;\n\n// This is the enum entry which will be used to identify the diagnostic\nconst DIAGNOSTIC_CODE: DiagnosticCode = DiagnosticCode::UnsafeFunctionCall;\n// This is a human-readable message that will be displayed in the IDE\nconst DIAGNOSTIC_MESSAGE: &str = "Do not use unsafe:operation/1 in production code.";\n// This is the severity of the diagnostic (Warning, Error, etc.)\nconst DIAGNOSTIC_SEVERITY: Severity = Severity::Warning;\n// This is the strategy used to match the pattern in the code.\nconst STRATEGY: Strategy = Strategy {\n    // In our case we want to expand macros before matching the pattern\n    macros: MacroStrategy::Expand,\n    // We don\'t care about parentheses in our case, so we ignore them\n    parens: ParenStrategy::InvisibleParens,\n};\n\n// This is the core of our linter.\npub(crate) static DESCRIPTOR: DiagnosticDescriptor = DiagnosticDescriptor {\n    // These are the conditions under which the diagnostic should run.\n    conditions: DiagnosticConditions {\n        experimental: false, // Experimental diagnostics are only enabled in `--experimental` mode\n        include_generated: false, // Do not run the linters against generated files\n        include_tests: false, // Do not run the linters against test files\n        default_disabled: false, // The diagnostic is enabled by default\n    },\n    // This is the function that will be called to run the diagnostic.\n    // `acc` is a vector of diagnostics which will be adding to.\n    checker: &|acc, sema, file_id, _ext| {\n        // We use the SSR mechanism to match calls to `unsafe:operation/1`.\n        let pattern = "ssr: unsafe:operation(_@).";\n        // We use the `match_pattern_in_file_functions` function to match the pattern in the code.\n        let matches = match_pattern_in_file_functions(sema, STRATEGY, file_id, pattern);\n        // We iterate over the matches and add a diagnostic for each one\n        matches.matches.iter().for_each(|m| {\n            // We create a new diagnostic with the code, message, and range of the match\n            let diagnostic = Diagnostic::new(DIAGNOSTIC_CODE, DIAGNOSTIC_MESSAGE, m.range.range)\n                .with_severity(DIAGNOSTIC_SEVERITY);\n            // We add the diagnostic to the accumulator\n            acc.push(diagnostic);\n        });\n    },\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-register-the-diagnostic",children:"Step 3: Register the diagnostic"}),"\n",(0,s.jsxs)(n.p,{children:["Add your diagnostic module to ",(0,s.jsx)(n.a,{href:"https://github.com/WhatsApp/erlang-language-platform/blob/main/crates/ide/src/diagnostics.rs",children:(0,s.jsx)(n.code,{children:"elp/crates/ide/src/diagnostics.rs"})}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"// Add the module declaration\nmod unsafe_function_call;\n\n// Register the descriptor in the diagnostics_descriptors function\npub fn diagnostics_descriptors() -> Vec<&'static DiagnosticDescriptor> {\n    vec![\n        // ... existing descriptors ...\n        &unsafe_function_call::DESCRIPTOR, // We add the descriptor here\n    ]\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-4-add-tests",children:"Step 4: Add tests"}),"\n",(0,s.jsxs)(n.p,{children:["At the bottom of the ",(0,s.jsx)(n.code,{children:"unsafe_function_call.rs"})," file, add the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[cfg(test)]\nmod tests {\n    use crate::tests::check_diagnostics;\n\n    #[test]\n    fn test_unsafe_function_call() {\n        check_diagnostics(\n            r#"\n            //- /src/main.erl\n            -module(main).\n            -export([warn/0]).\n            warn() ->\n                unsafe:operation(data),\n            %%  ^^^^^^^^^^^^^^^^^^^^^^ warning: Do not use unsafe:operation/1 in production code.\n                safe:operation(data).\n            //- /src/unsafe.erl\n            -module(unsafe).\n            -export([operation/1]).\n            operation(_) -> ok.\n            //- /src/safe.erl\n            -module(safe).\n            -export([operation/1]).\n            operation(_) -> ok.\n            "#,\n        );\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["ELP uses convenient snapshot tests for checking diagnostics. The test above\nchecks that the diagnostic is correctly reported when calling ",(0,s.jsx)(n.code,{children:"unsafe:operation/1"}),".\nIt also checks that the diagnostic is not reported when calling ",(0,s.jsx)(n.code,{children:"safe:operation/1"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Always include comprehensive tests in your diagnostic module:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Positive cases"})," - Code that should trigger the diagnostic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Negative cases"})," - Similar code that should NOT trigger the diagnostic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Edge cases"})," - Boundary conditions and unusual syntax"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You can run the tests with the following command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"cargo test --package elp_ide --lib -- diagnostics::unsafe_function_call::tests::test_unsafe_function_call --exact --show-output\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-5-create-documentation",children:"Step 5: Create documentation"}),"\n",(0,s.jsxs)(n.p,{children:["Each new linter must be accompanied by a documentation file in Markdown format.\nCreate the documentation file corresponding to your linter in:\n",(0,s.jsx)(n.code,{children:"elp/website/docs/erlang-error-index/w/W0055.md"})," (where ",(0,s.jsx)(n.code,{children:"W0055"})," is the code we introduced):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:"---\nsidebar_position: 55\n---\n\n# W0055 - Unsage Function Call\n\nThis diagnostic warns about calls to `unsafe:operation/1`, which should be\navoided in production code due to potential security or stability risks.\n`safe:operation/1` is a safer alternative that should be used instead.\n\n## Example\n\n```erlang\n-module(example).\n-export([do/1]).\n\ndo(Data) ->\n    unsafe:operation(Data).\n%%  ^^^^^^^^^^^^^^^^^^^^^^ warning: Do not use unsafe:operation/1 in production code.\n```\n\n## Recommended fix\n\nReplace calls to `unsafe:operation/1` with a safer alternative, such as `safe:operation/1`.\n\n```erlang\n-module(example).\n-export([do/1]).\n\ndo(Data) ->\n    safe:operation(Data).\n```\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-6-try-the-new-linter-from-the-cli",children:"Step 6: Try the new linter from the CLI"}),"\n",(0,s.jsxs)(n.p,{children:["After building ELP, you can try the new linter against a hypothetical ",(0,s.jsx)(n.code,{children:"my_module"})," Erlang module:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"cargo run --bin elp -- lint --project /path/to/your/project --module my_module --diagnostic-filter unsafe_function_call\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Diagnostics reported in 1 modules:\n  my_module: 1\n      29:4-29:25::[Warning] [W0055] Do not use unsafe:operation/1 in production code.\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(96540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);