"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[6198],{24792:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"contributing/code-actions","title":"Code Actions (a.k.a. Assists)","description":"Code actions, also known as assists, are small local refactorings, often rendered in the text editor using a light bulb icon (\ud83d\udca1). They are triggered by either clicking the light bulb icon in the editor or by using a shortcut.","source":"@site/docs/contributing/code-actions.md","sourceDirName":"contributing","slug":"/contributing/code-actions","permalink":"/erlang-language-platform/docs/contributing/code-actions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Linters","permalink":"/erlang-language-platform/docs/contributing/linters"},"next":{"title":"Architecture","permalink":"/erlang-language-platform/docs/architecture"}}');var s=t(74848),o=t(28453);const c={sidebar_position:2},a="Code Actions (a.k.a. Assists)",r={},d=[{value:"The <em>Code Action</em> request",id:"the-code-action-request",level:2},{value:"Adding a new code action",id:"adding-a-new-code-action",level:2},{value:"Creating the handler",id:"creating-the-handler",level:3},{value:"Adding a test case",id:"adding-a-test-case",level:3},{value:"Diagnostic Annotations and Error Codes",id:"diagnostic-annotations-and-error-codes",level:3},{value:"Matching on the diagnostic error code",id:"matching-on-the-diagnostic-error-code",level:3},{value:"The implementation",id:"the-implementation",level:3}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"code-actions-aka-assists",children:"Code Actions (a.k.a. Assists)"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Code actions"}),", also known as ",(0,s.jsx)(n.em,{children:"assists"}),", are small local refactorings, often rendered in the text editor using a light bulb icon (\ud83d\udca1). They are triggered by either clicking the light bulb icon in the editor or by using a shortcut."]}),"\n",(0,s.jsxs)(n.p,{children:["Code actions often provide the user with possible corrective actions right next to an error or warning (known as a ",(0,s.jsx)(n.em,{children:"diagnostic"})," message using LSP jargon). They can also occur independently of diagnostics."]}),"\n",(0,s.jsxs)(n.p,{children:["Here is an example of a ",(0,s.jsx)(n.em,{children:"code action"})," prompting the user to ",(0,s.jsx)(n.em,{children:"add an EDoc comment"})," for a function which lacks Erlang EDoc documentation."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Code Action - Add Edoc",src:t(35657).A+""})}),"\n",(0,s.jsx)(n.p,{children:"And this is what the code looks like after the suggestion has been applied:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Code Action - Add Edoc Fix",src:t(83439).A+""})}),"\n",(0,s.jsxs)(n.h2,{id:"the-code-action-request",children:["The ",(0,s.jsx)(n.em,{children:"Code Action"})," request"]}),"\n",(0,s.jsxs)(n.p,{children:["Code actions are requested by the editor using the ",(0,s.jsx)(n.a,{href:"https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_codeAction",children:"textDocument/codeAction"})," LSP request. Code action requests are handled by the ",(0,s.jsx)(n.code,{children:"handlers::handle_code_action"})," function in the ",(0,s.jsx)(n.code,{children:"elp"})," crate."]}),"\n",(0,s.jsx)(n.h2,{id:"adding-a-new-code-action",children:"Adding a new code action"}),"\n",(0,s.jsxs)(n.p,{children:["In this section we will go through the process of adding a new code action from scratch. The code action (or ",(0,s.jsx)(n.em,{children:"assist"}),") will suggest the user to delete a function, if it is deemed as unused by the Erlang compiler."]}),"\n",(0,s.jsx)(n.h3,{id:"creating-the-handler",children:"Creating the handler"}),"\n",(0,s.jsxs)(n.p,{children:["Let's start by creating a new file named ",(0,s.jsx)(n.code,{children:"delete_function.rs"}),", containing a single function declaration:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="crates/ide_assists/src/handlers/delete_function.rs"',children:"use crate::assist_context::{Assists, AssistContext};\n\npub(crate) fn delete_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n    todo!()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Before we can start implementing our code action, there's one more thing we need to do: ensure our new function is invoked by adding it to the list of ",(0,s.jsx)(n.em,{children:"ELP assists"}),". Open the ",(0,s.jsx)(n.code,{children:"crates/ide_assists/src/lib.rs"})," file and amend the list of handlers:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="crates/ide_assists/src/lib.rs"',children:"mod handlers {\n    [...]\n    mod delete_function\n    [...]\n\n    pub(crate) fn all() -> &'static [Handler] {\n        &[\n            [...]\n            delete_function:delete_function,\n            [...]\n        ]\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"adding-a-test-case",children:"Adding a test case"}),"\n",(0,s.jsx)(n.p,{children:"The easiest way to verify our new code action behaves in the expected way is to start with a test case. ELP allows us to write tests in a very intuitive and straightforward way."}),"\n",(0,s.jsxs)(n.p,{children:["Add the following to the ",(0,s.jsx)(n.code,{children:"delete_function.rs"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="crates/ide_assists/src/handlers/delete_function.rs"',children:'#[cfg(test)]\nmod tests {\n    use expect_test::expect;\n\n    use super::*;\n    use crate::tests::*;\n\n    #[test]\n    fn test_delete_unused_function() {\n        check_assist(\n            delete_function,\n            "Remove the unused function `heavy_calculations/1`",\n            r#"\n     -module(life).\n\n     heavy_cal~culations(X) ->\n  %% ^^^^^^^^^^^^^^^^^^^ \ud83d\udca1 L1230: Function heavy_calculations/1 is unused\n       X.\n\n     meaning() ->\n       42.\n"#,\n            expect![[\n                r#"\n                   -module(life).\n\n                   meaning() ->\n                     42.\n            "#]],\n        )\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["There is a lot happening here, so let's go through the code. We are defining a new test, named ",(0,s.jsx)(n.code,{children:"test_delete_unused_function"}),", which uses an auxiliary function (",(0,s.jsx)(n.code,{children:"check_assist"}),") to verify that a given assist behaves as expected."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"check_assist"})," function takes 4 arguments:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The assist ",(0,s.jsx)(n.em,{children:"handler"})," (",(0,s.jsx)(n.code,{children:"delete_function"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.em,{children:"label"})," for the assist"]}),"\n",(0,s.jsxs)(n.li,{children:["An input fixture representing what the code looks like ",(0,s.jsx)(n.strong,{children:"before"})," a fix is applied"]}),"\n",(0,s.jsxs)(n.li,{children:["An output fixture (wrapped in an ",(0,s.jsx)(n.code,{children:"expect"})," macro) showing what the code looks like ",(0,s.jsx)(n.strong,{children:"after"})," a fix is applied"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"~"})," in the first snippet represents the cursor position. We are asserting that - given a diagnostic message pointing to the unused function - if the user triggers the respective code action when the cursor is hovering the function name range, the unused function gets deleted."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's try running the test, it should fail with a ",(0,s.jsx)(n.em,{children:"not yet implemented"})," error:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"$ cargo test --package elp_ide_assists --lib -- handlers::delete_function::tests::test_delete_unused_function --exact --nocapture\n\n[...]\n---- handlers::delete_function::tests::test_delete_unused_function stdout ----\nthread 'handlers::delete_function::tests::test_delete_unused_function' panicked at 'not yet implemented', crates/ide_assists/src/handlers/delete_function.rs:21:5\n[...]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"diagnostic-annotations-and-error-codes",children:"Diagnostic Annotations and Error Codes"}),"\n",(0,s.jsxs)(n.p,{children:["Before starting with the actual implementation, let's for a second go back to the syntax we used to specify the ",(0,s.jsx)(n.em,{children:"unused function"})," diagnostic:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"%% ^^^^^^^^^^^^^^^^^^^ \ud83d\udca1 L1230: Function heavy_calculations/1 is unused\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is a test ",(0,s.jsx)(n.em,{children:"annotation"}),' which is used by the ELP testing framework to populate the "context" which is passed to our handler. This is a way to simulate diagnostics coming from external sources (such as the Erlang compiler or a linter), which would be received by the Language Server as part of a ',(0,s.jsx)(n.code,{children:"textDocument/codeAction"})," request."]}),"\n",(0,s.jsx)(n.p,{children:"The annotation has the following format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[\\s]%% [^]* \ud83d\udca1 CODE: MESSAGE\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Essentially, a number of spaces, followed by the ",(0,s.jsx)(n.code,{children:"%%"})," which resembles an Erlang comment, a light bulb, a ",(0,s.jsx)(n.em,{children:"code"})," identifying the diagnostic type and a string message. The ",(0,s.jsx)(n.em,{children:"code"}),"  is an ",(0,s.jsx)(n.em,{children:"unofficial error"})," code which is emitted by both ELP's ",(0,s.jsx)(n.em,{children:"Erlang Service"})," (see the ",(0,s.jsx)(n.code,{children:"erlang_service:make_code/2"})," function in ",(0,s.jsx)(n.code,{children:"erlang_service/src/erlang_service.erl"}),") and by the ",(0,s.jsx)(n.a,{href:"https://github.com/erlang-ls/erlang_ls/",children:"Erlang LS"})," language server. The idea is to eventually standardize Erlang error messages and to build what, in the end, should be similar to the ",(0,s.jsx)(n.a,{href:"https://doc.rust-lang.org/error-index.html",children:"Rust"})," or ",(0,s.jsx)(n.a,{href:"https://errors.haskell.org/",children:"Haskell"})," error indexes. In our case, ",(0,s.jsx)(n.code,{children:"L1230"})," is the error corresponding to the ",(0,s.jsx)(n.code,{children:"unused_function"})," diagnostic. The ",(0,s.jsx)(n.em,{children:"message"})," is a free text string that accompanies the diagnostic."]}),"\n",(0,s.jsx)(n.h3,{id:"matching-on-the-diagnostic-error-code",children:"Matching on the diagnostic error code"}),"\n",(0,s.jsxs)(n.p,{children:["To be able to match the ",(0,s.jsx)(n.code,{children:"L1230"})," error code, we need to add a new variant to the ",(0,s.jsx)(n.code,{children:"AssistContextDiagnosticCode"})," enum. Open the ",(0,s.jsx)(n.code,{children:"crates/ide_db/src/assists.rs"})," file and include the new error code. Don't forget to map it to the ",(0,s.jsx)(n.code,{children:"L1230"})," string."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="crates/ide_db/src/assists.rs"',children:'pub enum AssistContextDiagnosticCode {\n    UnusedFunction, // <--- Add this\n    [...]\n    UnusedVariable,\n}\n\nimpl FromStr for AssistContextDiagnosticCode {\n    type Err = String;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            "L1230" => Ok(AssistContextDiagnosticCode::UnusedFunction), // <--- Add this\n            [...]\n            "L1268" => Ok(AssistContextDiagnosticCode::UnusedVariable),\n            unknown => Err(format!("Unknown AssistContextDiagnosticCode: \'{unknown}\'")),\n        }\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We are all set. Time to implement the ",(0,s.jsx)(n.code,{children:"delete_function"})," function!"]}),"\n",(0,s.jsx)(n.h3,{id:"the-implementation",children:"The implementation"}),"\n",(0,s.jsx)(n.p,{children:"Let's look at our function again."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"pub(crate) fn delete_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n    todo!()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We have two input arguments: a mutable ",(0,s.jsx)(n.em,{children:"accumulator"})," which contains the list of code actions (or ",(0,s.jsx)(n.em,{children:"assists"}),") which we want to return and a ",(0,s.jsx)(n.em,{children:"context"}),", from which we can extract diagnostics."]}),"\n",(0,s.jsxs)(n.p,{children:["The following code iterates through the list of diagnostics and, for each diagnostic matching the ",(0,s.jsx)(n.code,{children:"UnusedFunction"})," kind, prints the diagnostic for debugging purposes. We return ",(0,s.jsx)(n.code,{children:"Some(())"})," to comply with the function signature."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"use elp_ide_db::assists::AssistContextDiagnosticCode;\n\n[...]\npub(crate) fn delete_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n    for d in ctx.diagnostics {\n        if let AssistContextDiagnosticCode::UnusedFunction = d.code {\n            dbg!(d);\n            todo!()\n        }\n    }\n    Some(())\n}\n[...]\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"If we run the test, we can see what a diagnostic looks like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'$ cargo test --package elp_ide_assists --lib -- handlers::delete_function::tests::test_delete_unused_function --exact --nocapture\n\n[...]\nrunning 1 test\n[crates/ide_assists/src/handlers/delete_function.rs:25] d = AssistContextDiagnostic {\n    code: UnusedFunction,\n    message: "Function heavy_calculations/1 is unused",\n    range: 24..40,\n}\n[...]\n'})}),"\n",(0,s.jsx)(n.p,{children:"The diagnostic contains the error code and message, together with its range. What we want to do is:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Find the function declaration which is pointed by the diagnostic range"}),"\n",(0,s.jsx)(n.li,{children:"Create a code action to remove the function declaration and add it to the accumulator"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["How do we find the element which the range covers? Context to the rescue! There's a handy ",(0,s.jsx)(n.code,{children:"find_node_at_custom_offset"})," function we can use. The ",(0,s.jsx)(n.em,{children:"offset"})," here indicates the number of bytes from the beginning of the file. We can use the beginning of the diagnostic range for our purposes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"let function_declaration: ast::FunDecl = ctx.find_node_at_custom_offset::<ast::FunDecl>(d.range.start())?;\nlet function_range = function_declaration.syntax().text_range();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let's extract the function name/arity and produce a nice message for the user:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'let function_name = function_declaration.name()?;\nlet function_arity = function_declaration.arity_value()?;\nlet message = format!("Remove the unused function `{function_name}/{function_arity}`");\n'})}),"\n",(0,s.jsx)(n.p,{children:"With the information we have, we can now create a new code action and add it to the accumulator:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'let id = AssistId("delete_function", AssistKind::QuickFix);\nlet function_range = function_declaration.syntax().text_range();\nacc.add(id,\n    message,\n    function_range,\n    |builder| {\n        builder.edit_file(ctx.frange.file_id);\n        builder.delete(function_range)\n    },\n);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"add"})," function takes four arguments:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["An internal ",(0,s.jsx)(n.code,{children:"AssistId"})," made of a unique string (the ",(0,s.jsx)(n.code,{children:'"delete_function"'})," string in our case) and a ",(0,s.jsx)(n.code,{children:"Kind"}),". We are specifying ",(0,s.jsx)(n.code,{children:"QuickFix"})," in our case, but have a look to the ",(0,s.jsx)(n.a,{href:"https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#codeActionKind",children:"LSP specifications"})," to get a list of the available kinds."]}),"\n",(0,s.jsxs)(n.li,{children:["A message which will be rendered to the user (",(0,s.jsx)(n.code,{children:'"Delete the unused function: [FUNCTION_NAME]"'}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["The range of the function. Notice how the range we got from the diagnostic was covering only the ",(0,s.jsx)(n.em,{children:"name"})," of the function, but we need to delete the whole function, so we need to pass the full range."]}),"\n",(0,s.jsxs)(n.li,{children:["A function which takes a ",(0,s.jsx)(n.code,{children:"builder"})," as its input and uses it to manipulate the source file. Here we are saying that we want to edit the current file (we extract the ",(0,s.jsx)(n.code,{children:"file_id"})," from the ",(0,s.jsx)(n.code,{children:"ctx"})," context) and that we simply want to delete the range of the function declaration."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Yes. It's as simple as that. For completeness, here is the full function implementation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'pub(crate) fn delete_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n    for d in ctx.diagnostics {\n        if let AssistContextDiagnosticCode::UnusedFunction = d.code {\n            let function_declaration: ast::FunDecl =\n                ctx.find_node_at_custom_offset::<ast::FunDecl>(d.range.start())?;\n            let function_name = function_declaration.name()?;\n            let function_arity = function_declaration.arity_value()?;\n            let function_range = function_declaration.syntax().text_range();\n\n            let id = AssistId("delete_function", AssistKind::QuickFix);\n            let message = format!("Remove the unused function `{function_name}/{function_arity}`");\n            acc.add(id, message, function_range, |builder| {\n                builder.edit_file(ctx.frange.file_id);\n                builder.delete(function_range)\n            });\n        }\n    }\n    Some(())\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"You can look at existing assists for more complex manipulation examples."}),"\n",(0,s.jsx)(n.h1,{id:"try-it-yourself",children:"Try it yourself"}),"\n",(0,s.jsx)(n.p,{children:"What we wrote is a unit test, but there's nothing better than checking ourselves the behaviour in the IDE."}),"\n",(0,s.jsxs)(n.p,{children:["Compile the ",(0,s.jsx)(n.code,{children:"elp"})," executable:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"cargo build\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then visit the Erlang extension settings page and edit the ",(0,s.jsx)(n.code,{children:"elp.path"})," value to point to the newly built executable, which should reside in:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"./debug/elp\n"})}),"\n",(0,s.jsx)(n.p,{children:"Open VS Code (or reload the window if you have it already open) and visit an Erlang file which contains an unused function. You should see something like:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Code Action - Remove Function",src:t(30337).A+""})}),"\n",(0,s.jsx)(n.p,{children:"If that worked, congratulations! You managed to write your first ELP code action!"})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},83439:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/code-action-add-edoc-fix-41b68bc5f8f0af57dd2dcdc686e0d850.png"},35657:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/code-action-add-edoc-00c08bb4c5326a4f4544e606890fd667.png"},30337:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/code-action-remove-function-17500a18e85501d12d483dc13df76153.png"},28453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>a});var i=t(96540);const s={},o=i.createContext(s);function c(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);