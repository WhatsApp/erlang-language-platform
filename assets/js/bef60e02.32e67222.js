"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[2291],{74111:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"erlang-error-index/w/W0023","title":"W0023 - Risk of Atoms Exhaustion","description":"Error","source":"@site/docs/erlang-error-index/w/W0023.md","sourceDirName":"erlang-error-index/w","slug":"/erlang-error-index/w/W0023","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0023","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":23,"frontMatter":{"sidebar_position":23},"sidebar":"tutorialSidebar","previous":{"title":"W0022 - Missing no_link option in meck:new invocation","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0022"},"next":{"title":"W0024 - Slow Function","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0024"}}');var o=t(74848),i=t(28453);const s={sidebar_position:23},a="W0023 - Risk of Atoms Exhaustion",c={},d=[{value:"Error",id:"error",level:2},{value:"Explanation",id:"explanation",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"w0023---risk-of-atoms-exhaustion",children:"W0023 - Risk of Atoms Exhaustion"})}),"\n",(0,o.jsx)(n.h2,{id:"error",children:"Error"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-erlang",children:"   -module(main).\n\n   -export([do/0]).\n\n   do() ->\n     [binary_to_atom(<<I/integer>>) || I <- lists:seq(1, 100)].\n   %% ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \ud83d\udca1 error: Risk of atoms exhaustion.\n"})}),"\n",(0,o.jsx)(n.h2,{id:"explanation",children:"Explanation"}),"\n",(0,o.jsxs)(n.p,{children:["Erlang atoms are not garbage-collected. Once an atom is created, it is never removed. The emulator terminates if the ",(0,o.jsx)(n.a,{href:"https://www.erlang.org/doc/efficiency_guide/advanced#system-limits",children:"configurable limit"})," for the number of atoms is reached."]}),"\n",(0,o.jsxs)(n.p,{children:["Therefore, converting arbitrary input strings or binaries to atoms can be dangerous in a system that runs continuously. All functions which can create atoms have a ",(0,o.jsx)(n.em,{children:"safe"})," variant which should be favoured when possible:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Conversion Function"}),(0,o.jsx)(n.th,{children:"Safer Version"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"list_to_atom/1"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"list_to_existing_atom/1"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"binary_to_atom/1,2"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"binary_to_existing_atom/1,2"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"binaty_to_term/1,2"})}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"binary_to_term/2"})," with the ",(0,o.jsx)(n.code,{children:"safe"})," option"]})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["When using the ",(0,o.jsx)(n.em,{children:"safe"})," or ",(0,o.jsx)(n.em,{children:"existing"})," versions of the above conversion functions, all atoms ",(0,o.jsx)(n.strong,{children:"must have been created earlier"})," or the function will cause an exception:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'1> binary_to_existing_atom(<<"this_atom_does_not_exist">>).\n** exception error: bad argument\n     in function  binary_to_existing_atom/1\n        called as binary_to_existing_atom(<<"this_atom_does_not_exist">>)\n        *** argument 1: not an already existing atom\n'})}),"\n",(0,o.jsx)(n.p,{children:"To explicitly create necessary atoms beforehand, you can export a function that returns a list of all atoms which are expected:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"-export([atoms/0]).\natoms() ->\n  [my_atom, your_atom, our_atom].\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If there is no way to know atom names in advance and there is ",(0,o.jsx)(n.strong,{children:"100% confidence in bounded string variations passed to the conversion function"})," you can preceed the conversion function call with a special comment to silent the linter:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"% elp:ignore atoms_exhaustion - An optional explanation here\n"})}),"\n",(0,o.jsxs)(n.p,{children:["For more information see the ",(0,o.jsx)(n.a,{href:"https://erlef.github.io/security-wg/secure_coding_and_deployment_hardening/atom_exhaustion",children:"Atom Exhausion"})," section of the Erlang Ecosystem Foundation Security Work Group."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(96540);const o={},i=r.createContext(o);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);