"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[1586],{20559:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"erlang-error-index/w/W0049","title":"W0049 - Prefer [{version, 2}] when constructing a set","description":"Error","source":"@site/docs/erlang-error-index/w/W0049.md","sourceDirName":"erlang-error-index/w","slug":"/erlang-error-index/w/W0049","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0049","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":49,"frontMatter":{"sidebar_position":49},"sidebar":"tutorialSidebar","previous":{"title":"W0048 - Avoid -dialyzer attribute","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0048"},"next":{"title":"W0050 - Avoid using the size/1 BIF","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0050"}}');var t=r(74848),o=r(28453);const i={sidebar_position:49},a="W0049 - Prefer [{version, 2}] when constructing a set",c={},l=[{value:"Error",id:"error",level:2},{value:"Explanation",id:"explanation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsxs)(n.h1,{id:"w0049---prefer-version-2-when-constructing-a-set",children:["W0049 - Prefer ",(0,t.jsx)(n.code,{children:"[{version, 2}]"})," when constructing a set"]})}),"\n",(0,t.jsx)(n.h2,{id:"error",children:"Error"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-erlang",children:"-module(main).\nfoo() -> sets:new().\n%%       ^^^^^^^^^^ \ud83d\udca1 warning: Prefer `[{version, 2}]` when constructing a set.\n"})}),"\n",(0,t.jsx)(n.h2,{id:"explanation",children:"Explanation"}),"\n",(0,t.jsxs)(n.p,{children:["Erlang/OTP 24.0 introduced a new internal representation for sets which is more\nperformant. Developers can use this new representation by passing the\n",(0,t.jsx)(n.code,{children:"{version, 2}"})," flag to ",(0,t.jsx)(n.code,{children:"new/1"})," and ",(0,t.jsx)(n.code,{children:"from_list/2"}),", such as\n",(0,t.jsx)(n.code,{children:"sets:new([{version, 2}])"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," This diagnostic is only active for OTP versions prior to OTP 28. In\nErlang/OTP 28 and later, version 2 is the default representation, making this\ndiagnostic unnecessary. Developers can use the old representation by passing the\n",(0,t.jsx)(n.code,{children:"{version, 1}"})," flag to ",(0,t.jsx)(n.code,{children:"new/1"})," and ",(0,t.jsx)(n.code,{children:"from_list/2"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Functions that work on two sets, such as ",(0,t.jsx)(n.code,{children:"union/2"})," and similar, will work with\nsets of different versions. In such cases, there is no guarantee about the\nversion of the returned set. Explicit conversion from the old version to the new\none can be done with ",(0,t.jsx)(n.code,{children:"sets:from_list(sets:to_list(Old), [{version,2}])"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["For more information, see ",(0,t.jsx)(n.a,{href:"https://www.erlang.org/doc/man/sets.html",children:"https://www.erlang.org/doc/man/sets.html"})]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var s=r(96540);const t={},o=s.createContext(t);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);