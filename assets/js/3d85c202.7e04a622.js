"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[3894],{13024:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>l});const c=JSON.parse('{"id":"erlang-error-index/w/W0052","title":"W0052 - Avoid catch","description":"Warning","source":"@site/docs/erlang-error-index/w/W0052.md","sourceDirName":"erlang-error-index/w","slug":"/erlang-error-index/w/W0052","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0052","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":52,"frontMatter":{"sidebar_position":52},"sidebar":"tutorialSidebar","previous":{"title":"W0051 - Binary string can be written using sigil syntax","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0051"},"next":{"title":"W0053 - The error_logger module is deprecated","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0053"}}');var a=r(74848),t=r(28453);const s={sidebar_position:52},i="W0052 - Avoid catch",o={},l=[{value:"Warning",id:"warning",level:2},{value:"Explanation",id:"explanation",level:2},{value:"Examples",id:"examples",level:2},{value:"Preserving the old behaviour",id:"preserving-the-old-behaviour",level:2},{value:"See also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsxs)(n.h1,{id:"w0052---avoid-catch",children:["W0052 - Avoid ",(0,a.jsx)(n.code,{children:"catch"})]})}),"\n",(0,a.jsx)(n.h2,{id:"warning",children:"Warning"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-erlang",children:"-module(main).\n-export([catcher/2]).\n\ncatcher(X,Y) ->\ncase catch X/Y of\n  %% ^^^^^ warning: Avoid `catch`.\n  {'EXIT', {badarith,_}} -> \"uh oh\";\n  N -> N\nend.\n"})}),"\n",(0,a.jsx)(n.h2,{id:"explanation",children:"Explanation"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"try ... catch ... end"})," in Erlang has been available for a very long time, and\nthe old, simplistic ",(0,a.jsx)(n.code,{children:"catch Expr"})," will be dropped from the language. In most\nplaces where it is used, it carries with it some unwanted (and often unknown)\ncorner case behaviour, such as discarding the original error location,\nconflating errors, exits, and throws, and mixing up thrown values with normally\nreturned values in a way that makes it very hard to see what the author\nintended, and whether the implementation really does what they hoped.\nMaintainance of such code is very hard."]}),"\n",(0,a.jsxs)(n.p,{children:["Starting with Erlang OTP 28, it will be possible to enable warnings for use of\nold-style ",(0,a.jsx)(n.code,{children:"catch"})," expressions via the ",(0,a.jsx)(n.code,{children:"warn_deprecated_catch"})," flag. The\nold-style catch will be deprecated and removed in a future version of OTP (most\nlikely OTP 29 or OTP 30). Therefore, it is recommended to avoid switching to\n",(0,a.jsx)(n.code,{children:"try ... catch ... end"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(n.p,{children:"Let's consider the following example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-erlang",children:"case catch api() of\n  {'EXIT', Reason} ->\n    caught_it;\n  _ ->\n    other\nend.\n"})}),"\n",(0,a.jsxs)(n.p,{children:["First notice that this always returns ",(0,a.jsx)(n.code,{children:"other"})," if ",(0,a.jsx)(n.code,{children:"api()"})," calls ",(0,a.jsx)(n.code,{children:"throw(...)"}),"\nbecause ",(0,a.jsx)(n.code,{children:"foo = (catch throw(foo))"}),". We only get something interesting if ",(0,a.jsx)(n.code,{children:"api()"}),"\ncalls ",(0,a.jsx)(n.code,{children:"exit(...)"})," or ",(0,a.jsx)(n.code,{children:"error(...)"}),". So, if your goal was to do something special\nwhen there is an exception, ",(0,a.jsx)(n.code,{children:"case catch"})," is definitely not what you want."]}),"\n",(0,a.jsxs)(n.p,{children:["If you only want to catch exits and errors, it might work, unless the API\nlegitimately returns a tuple with first element being ",(0,a.jsx)(n.code,{children:"'EXIT'"}),". So, this pattern\nis brittle and does not generalize. Here is a better way:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-erlang",children:"try api() of\n  _ ->\n    other\ncatch\n  _:_ ->\n    caught_it\nend.\n"})}),"\n",(0,a.jsxs)(n.p,{children:["It is only one line longer than ",(0,a.jsx)(n.code,{children:"case catch"}),", does not miss ",(0,a.jsx)(n.code,{children:"throw()"}),"s, has less\nruntime overhead, has 15 fewer characters, and never trips on special return\nvalues of functions."]}),"\n",(0,a.jsxs)(n.p,{children:["One case where using ",(0,a.jsx)(n.code,{children:"try/catch"})," is more cumbersome is if you want to treat\nexceptions and unexpected return values the same. In that case you may want to\ndo:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-erlang",children:"case catch api() of\n    expected -> continue_processing();\n    Other -> handle_unexpected(Other)\nend.\n"})}),"\n",(0,a.jsxs)(n.p,{children:["However, if ",(0,a.jsx)(n.code,{children:"api()"})," calls ",(0,a.jsx)(n.code,{children:"throw(expected)"})," it gets treated the same as if it\nreturns expected. This makes the intended interface of ",(0,a.jsx)(n.code,{children:"api()"})," unclear. So, it\nis still recommended to use ",(0,a.jsx)(n.code,{children:"try/catch"})," for this case:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-erlang",children:"try api() of\n    expected -> continue_processing();\n    Other -> handle_unexpected(Other)\ncatch\n    Type:Reason -> handle_unexpected(Type, Reason)\nend.\n"})}),"\n",(0,a.jsx)(n.p,{children:"It is more verbose but makes the interface and control flow clear."}),"\n",(0,a.jsx)(n.h2,{id:"preserving-the-old-behaviour",children:"Preserving the old behaviour"}),"\n",(0,a.jsxs)(n.p,{children:["When converting a ",(0,a.jsx)(n.code,{children:"catch"})," into a ",(0,a.jsx)(n.code,{children:"try ... catch ... end"}),", keep in mind that we\nmay rely on the result of the ",(0,a.jsx)(n.code,{children:"catch"})," expression itself."]}),"\n",(0,a.jsx)(n.p,{children:"As an example, it would be ok to replace:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-erlang",children:"sum(X, Y) ->\n  catch could_crash(X),\n  X + Y.\n"})}),"\n",(0,a.jsx)(n.p,{children:"With:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-erlang",children:"sum(X, Y) ->\n  try could_crash(X)\n  catch\n    _:_ ->\n      ok\n  end,\n  X + Y.\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This is because the code inside the ",(0,a.jsx)(n.code,{children:"catch"})," (then converted into a\n",(0,a.jsx)(n.code,{children:"try ... catch ... end"}),") is only used for its ",(0,a.jsx)(n.em,{children:"side effects"}),", and the result of\nthe ",(0,a.jsx)(n.code,{children:"could_crash/1"})," function is ignored."]}),"\n",(0,a.jsx)(n.p,{children:"Things are different in the following example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-erlang",children:"main(X) ->\n  catch could_crash(X).\n\ncould_crash(42) ->\n  throw(crash);\ncould_crash(_X) ->\n  ok.\n"})}),"\n",(0,a.jsxs)(n.p,{children:["One could mechanically convert the ",(0,a.jsx)(n.code,{children:"catch"})," into a ",(0,a.jsx)(n.code,{children:"try ... catch"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-erlang",children:"main(X) ->\n  try could_crash(X)\n  catch _:_ ->\n    ok\n  end.\n\ncould_crash(42) ->\n  throw(crash);\ncould_crash(_X) ->\n  ok.\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This conversion could be potentially dangerous and should be rethinked, since\nthe old behaviour is not preserved. In fact, when calling ",(0,a.jsx)(n.code,{children:"my_function(42)"}),", the\nold code returns ",(0,a.jsx)(n.code,{children:"crash"}),", while the new code returns ",(0,a.jsx)(n.code,{children:"ok"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"By examining the surrounding code you should be able to assess whether a\npotentially backward incompatible behaviour is acceptable or not."}),"\n",(0,a.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.erlang.org/doc/system/errors.html",children:"Errors and Error Handling"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/erlang/otp/pull/9154",children:"Deprecating catch in Erlang"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://stackoverflow.com/questions/46885820/erlang-catch-expression-vs-try-catch-in-terms-of-efficiency",children:"Erlang 'catch' expression vs try/catch in terms of efficiency"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://learnyousomeerlang.com/errors-and-exceptions",children:"Dealing with exceptions"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>i});var c=r(96540);const a={},t=c.createContext(a);function s(e){const n=c.useContext(t);return c.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),c.createElement(t.Provider,{value:n},e.children)}}}]);