"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[1015],{13909:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"contributing/linters/linters-step-1-diagnostic-code","title":"Add a Diagnostic Code","description":"We will create a new linter, which warns about calls to a hypothetical","source":"@site/docs/contributing/linters/linters-step-1-diagnostic-code.md","sourceDirName":"contributing/linters","slug":"/contributing/linters/linters-step-1-diagnostic-code","permalink":"/erlang-language-platform/docs/contributing/linters/linters-step-1-diagnostic-code","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Add a Diagnostic Code"},"sidebar":"tutorialSidebar","previous":{"title":"Linters","permalink":"/erlang-language-platform/docs/contributing/linters/"},"next":{"title":"Create the linter module","permalink":"/erlang-language-platform/docs/contributing/linters/linters-step-2-module"}}');var s=t(74848),o=t(28453);const a={sidebar_position:1,title:"Add a Diagnostic Code"},r=void 0,c={},d=[];function l(e){const n={a:"a",code:"code",em:"em",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["We will create a new linter, which warns about calls to a hypothetical\n",(0,s.jsx)(n.code,{children:"unsafe:operation/1"})," API that should be avoided in production code."]}),"\n",(0,s.jsxs)(n.p,{children:["Start by adding a new variant to the ",(0,s.jsx)(n.code,{children:"DiagnosticCode"})," enum in\n",(0,s.jsx)(n.a,{href:"https://github.com/WhatsApp/erlang-language-platform/blob/main/crates/ide_db/src/diagnostic_code.rs",children:(0,s.jsx)(n.code,{children:"crates/ide_db/src/diagnostic_code.rs"})}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"{3} showLineNumbers",children:"pub enum DiagnosticCode {\n    // ... existing codes ...\n    NoUnsafeOperation, // This is the new code\n\n    // Wrapper for erlang service diagnostic codes\n    ErlangService(String),\n    // Wrapper for EqWAlizer diagnostic codes\n    Eqwalizer(String),\n    // Used for ad-hoc diagnostics via lints/codemods\n    AdHoc(String),\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Ensure the code name is unique and descriptive. We will call it the ",(0,s.jsx)(n.em,{children:'"No Unsafe\nOperation"'})," linter. Then add a clause for each of the required methods:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"{10,24,37} showLineNumbers",children:'impl DiagnosticCode {\n    // The `as_code` method returns a string representation of the code.\n    // This is used to identify the diagnostic in the UI and in the CLI.\n    // Each code emitted by ELP starts with a `W` prefix, followed by a 4-digit number.\n    // The number is assigned by the linter author and should be unique within the linter.\n    // Use the next available number in the sequence for your new linter.\n    pub fn as_code(&self) -> &\'static str {\n        match self {\n            // ... existing cases ...\n            DiagnosticCode::NoUnsafeOperation => "W0055", // Use next available number here\n\n            DiagnosticCode::ErlangService(c) => c.to_string(),\n            DiagnosticCode::Eqwalizer(c) => format!("eqwalizer: {c}"),\n            DiagnosticCode::AdHoc(c) => format!("ad-hoc: {c}"),\n        }\n    }\n\n    // The `as_label` method returns a human-readable label for the diagnostic.\n    // This is used to identify the diagnostic in the UI and in the CLI.\n    // The label should be unique and descriptive.\n    pub fn as_label(&self) -> &\'static str {\n        match self {\n            // ... existing cases ...\n            DiagnosticCode::NoUnsafeOperation => "no_unsafe_operation", // Use snake_case here\n\n            DiagnosticCode::ErlangService(c) => c.to_string(),\n            DiagnosticCode::Eqwalizer(c) => c.to_string(),\n            DiagnosticCode::AdHoc(c) => format!("ad-hoc: {c}"),\n        }\n    }\n\n    // The `allows_fixme_comment` method determines if it should be possible to temporarily\n    // suppress the diagnostic by a `% elp:fixme` annotation.\n    pub fn allows_fixme_comment(&self) -> bool {\n        match self {\n            // ... existing cases ...\n            DiagnosticCode::NoUnsafeOperationLinter => false,\n\n            DiagnosticCode::ErlangService(_) => false,\n            DiagnosticCode::Eqwalizer(_) => false,\n            DiagnosticCode::AdHoc(_) => false,\n        }\n    }\n\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(96540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);