"use strict";(self.webpackChunkstaticdocs_starter=self.webpackChunkstaticdocs_starter||[]).push([[1586],{20559:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"erlang-error-index/w/W0049","title":"W0049 - Prefer [{version, 2}] when constructing a set","description":"Error","source":"@site/docs/erlang-error-index/w/W0049.md","sourceDirName":"erlang-error-index/w","slug":"/erlang-error-index/w/W0049","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0049","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":49,"frontMatter":{"sidebar_position":49},"sidebar":"tutorialSidebar","previous":{"title":"W0048 - Avoid -dialyzer attribute","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0048"},"next":{"title":"W0050 - Avoid using the size/1 BIF","permalink":"/erlang-language-platform/docs/erlang-error-index/w/W0050"}}');var s=r(74848),o=r(28453);const i={sidebar_position:49},a="W0049 - Prefer [{version, 2}] when constructing a set",c={},l=[{value:"Error",id:"error",level:2},{value:"Explanation",id:"explanation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsxs)(n.h1,{id:"w0049---prefer-version-2-when-constructing-a-set",children:["W0049 - Prefer ",(0,s.jsx)(n.code,{children:"[{version, 2}]"})," when constructing a set"]})}),"\n",(0,s.jsx)(n.h2,{id:"error",children:"Error"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-erlang",children:"-module(main).\nfoo() -> sets:new().\n%%       ^^^^^^^^^^ \ud83d\udca1 warning: Prefer `[{version, 2}]` when constructing a set.\n"})}),"\n",(0,s.jsx)(n.h2,{id:"explanation",children:"Explanation"}),"\n",(0,s.jsxs)(n.p,{children:["Erlang/OTP 24.0 introduced a new internal representation for sets which is more\nperformant. Developers can use this new representation by passing the\n",(0,s.jsx)(n.code,{children:"{version, 2}"})," flag to ",(0,s.jsx)(n.code,{children:"new/1"})," and ",(0,s.jsx)(n.code,{children:"from_list/2"}),", such as\n",(0,s.jsx)(n.code,{children:"sets:new([{version, 2}])."})," This new representation will become the default in\nfuture Erlang/OTP versions. Functions that work on two sets, such as ",(0,s.jsx)(n.code,{children:"union/2"}),"\nand similar, will work with sets of different versions. In such cases, there is\nno guarantee about the version of the returned set. Explicit conversion from the\nold version to the new one can be done with\n",(0,s.jsx)(n.code,{children:"sets:from_list(sets:to_list(Old), [{version,2}])"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For more information, see ",(0,s.jsx)(n.a,{href:"https://www.erlang.org/doc/man/sets.html",children:"https://www.erlang.org/doc/man/sets.html"})]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(96540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);